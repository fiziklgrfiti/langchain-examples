#!/usr/bin/env python3
"""
Security Analyzer Script

This script analyzes files listed in a YAML file generated by the directory scanner,
and adds security descriptions and observations using Ollama and LangChain.
It skips files that have been recently reviewed and not modified since.
"""

import os
import yaml
import argparse
import datetime
from pathlib import Path
from typing import Dict, List, Set, Any, Optional
import time
import re
from datetime import timedelta

from langchain_community.llms import Ollama
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser

# Global constants
DEFAULT_MODEL = "llama3.1:latestllama3.1:latest"
DEFAULT_RECENT_DAYS = 90
DEFAULT_MAX_FILE_SIZE_MB = 5
DEFAULT_TIMEOUT = 120

# Default file types to prioritize for code analysis
DEFAULT_CODE_FILE_TYPES = [
    "text/x-python", 
    "text/x-sh", 
    "text/x-java", 
    "text/x-c++", 
    "text/x-javascript",
    "text/javascript",
    "application/javascript",
    "text/html",
    "text/css",
    "application/json",
    "application/xml",
    "text/xml",
    "application/x-php",
    "text/x-php",
    "text/x-ruby",
    "text/x-perl",
    "text/x-go",
    "text/x-rust",
    "application/yaml",
    "text/x-yaml",
    "text/markdown"
]

class SecurityAnalyzer:
    """Class to analyze files for security issues and update YAML data"""
    
    def __init__(
        self, 
        yaml_file: str, 
        target_dir: str, 
        model_name: str = DEFAULT_MODEL,
        recent_days: int = DEFAULT_RECENT_DAYS,
        max_file_size_mb: float = DEFAULT_MAX_FILE_SIZE_MB,
        skip_reviewed: bool = True,
        file_types: Optional[List[str]] = None,
        force_all: bool = False,
        verbose: bool = False
    ):
        """
        Initialize the SecurityAnalyzer
        
        Args:
            yaml_file (str): Path to the YAML file containing file information
            target_dir (str): Path to the target directory
            model_name (str): Name of the Ollama model to use
            recent_days (int): Number of days to consider a file as recently reviewed
            max_file_size_mb (float): Maximum file size in MB to analyze
            skip_reviewed (bool): Whether to skip files that have been recently reviewed
            file_types (List[str]): List of file types to analyze (None for all)
            force_all (bool): Force analysis of all files regardless of review status
            verbose (bool): Whether to print verbose output
        """
        self.yaml_file = yaml_file
        self.target_dir = target_dir
        self.model_name = model_name
        self.recent_days = recent_days
        self.max_file_size_bytes = int(max_file_size_mb * 1024 * 1024)
        self.skip_reviewed = skip_reviewed
        self.file_types = file_types if file_types else DEFAULT_CODE_FILE_TYPES
        self.force_all = force_all
        self.verbose = verbose
        
        # Load YAML data
        self.yaml_data = self._load_yaml()
        
        # Initialize Ollama LLM
        self.llm = self._setup_ollama()
        
        # Setup analysis chain
        self.description_chain, self.security_chain = self._setup_chains()
        
        # Track statistics
        self.stats = {
            "total_files": 0,
            "analyzed_files": 0,
            "skipped_recently_reviewed": 0,
            "skipped_size": 0,
            "skipped_file_type": 0,
            "errors": 0
        }
    
    def _load_yaml(self) -> Dict:
        """Load the YAML data from file"""
        try:
            with open(self.yaml_file, 'r') as f:
                return yaml.safe_load(f)
        except Exception as e:
            print(f"Error loading YAML file: {e}")
            exit(1)
    
    def _setup_ollama(self):
        """Initialize the Ollama LLM"""
        try:
            return Ollama(
                model=self.model_name,
                temperature=0.1,  # Low temperature for consistent results
                timeout=DEFAULT_TIMEOUT
            )
        except Exception as e:
            print(f"Error setting up Ollama: {e}")
            print("Make sure Ollama is running and the model is available")
            exit(1)
    
    def _setup_chains(self):
        """Setup LangChain chains for description and security analysis"""
        # Description prompt
        description_prompt = PromptTemplate.from_template(
            """You are a security-focused software developer tasked with analyzing files.
            
            Provide a concise 1-2 sentence description of what this file does based on its name, type, and contents.
            Focus on the file's purpose, not its implementation details.
            
            File Name: {file_name}
            File Type: {file_type}
            File Location: {file_path}
            File Size: {file_size} bytes
            File Contents:
            {file_contents}
            
            Description:"""
        )
        
        # Security observations prompt
        security_prompt = PromptTemplate.from_template(
            """You are a security-focused software developer tasked with analyzing files for security issues.
            
            Examine the following file and provide a concise list of potential security observations or risks.
            Focus on specific security concerns, not general code quality issues.
            If no obvious security issues are found, mention this but suggest areas that might need deeper review.
            Your response should be 2-5 short bullet points.
            
            File Name: {file_name}
            File Type: {file_type}
            File Location: {file_path}
            File Size: {file_size} bytes
            File Contents:
            {file_contents}
            
            Security observations:"""
        )
        
        # Create chains
        description_chain = description_prompt | self.llm | StrOutputParser()
        security_chain = security_prompt | self.llm | StrOutputParser()
        
        return description_chain, security_chain
    
    def _is_recently_reviewed(self, file_entry: Dict) -> bool:
        """
        Check if a file has been recently reviewed and not modified since
        
        Args:
            file_entry (Dict): The file entry from the YAML data
            
        Returns:
            bool: True if the file has been recently reviewed and not modified, False otherwise
        """
        # If force_all is True, always return False (not recently reviewed)
        if self.force_all:
            return False
            
        metadata = file_entry.get('metadata', {})
        
        # If no last_reviewed date, it's not recently reviewed
        if not metadata.get('last_reviewed'):
            return False
        
        try:
            # Parse dates
            last_reviewed_str = metadata.get('last_reviewed', '')
            last_modified_str = metadata.get('last_modified', '')
            
            if not last_reviewed_str or not last_modified_str:
                return False
                
            last_reviewed = datetime.datetime.fromisoformat(last_reviewed_str)
            last_modified = datetime.datetime.fromisoformat(last_modified_str)
            
            # Check if file was modified after review
            if last_modified > last_reviewed:
                return False
                
            # Check if review is recent enough
            now = datetime.datetime.now()
            recent_threshold = now - datetime.timedelta(days=self.recent_days)
            
            return last_reviewed >= recent_threshold
            
        except Exception as e:
            if self.verbose:
                print(f"Error checking review status: {e}")
            return False
    
    def _should_analyze_file(self, file_entry: Dict) -> bool:
        """
        Determine if a file should be analyzed based on review status and file type
        
        Args:
            file_entry (Dict): The file entry from the YAML data
            
        Returns:
            bool: True if the file should be analyzed, False otherwise
        """
        # Check size
        file_size = file_entry.get('metadata', {}).get('size_bytes', 0)
        if file_size > self.max_file_size_bytes:
            self.stats["skipped_size"] += 1
            return False
            
        # Check review status
        if self.skip_reviewed and self._is_recently_reviewed(file_entry):
            self.stats["skipped_recently_reviewed"] += 1
            return False
            
        # Check file type
        file_type = file_entry.get('file_type', '')
        
        # If file_types is empty or None, analyze all files
        if not self.file_types:
            return True
            
        # Check if file type is in allowed types
        for allowed_type in self.file_types:
            if allowed_type in file_type:
                return True
                
        self.stats["skipped_file_type"] += 1
        return False
    
    def _read_file_content(self, file_path: str) -> str:
        """
        Read the content of a file
        
        Args:
            file_path (str): Path to the file
            
        Returns:
            str: The content of the file, or an error message
        """
        try:
            full_path = os.path.join(self.target_dir, file_path)
            
            # Check file size before reading
            size = os.path.getsize(full_path)
            if size > self.max_file_size_bytes:
                return f"[File too large to analyze: {size / (1024*1024):.2f} MB]"
                
            with open(full_path, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
                
            # Truncate very large content to avoid overwhelming the model
            max_chars = 15000  # Reasonable limit for model context
            if len(content) > max_chars:
                content = content[:max_chars] + "\n[Content truncated due to size...]"
                
            return content
        except Exception as e:
            return f"[Error reading file: {e}]"
    
    def _analyze_file(self, file_entry: Dict) -> Dict:
        """
        Analyze a file and update its description and security observations
        
        Args:
            file_entry (Dict): The file entry from the YAML data
            
        Returns:
            Dict: The updated file entry
        """
        folder = file_entry.get('folder', '')
        file_name = file_entry.get('file_name', '')
        file_type = file_entry.get('file_type', '')
        file_size = file_entry.get('metadata', {}).get('size_bytes', 0)
        
        file_path = os.path.join(folder, file_name) if folder else file_name
        
        if self.verbose:
            print(f"Analyzing: {file_path}")
        
        # Read file content
        file_contents = self._read_file_content(file_path)
        
        # Skip if file couldn't be read properly
        if file_contents.startswith('[Error'):
            file_entry['description'] = "Error: Could not read file for analysis"
            file_entry['security_observations'] = "File needs manual review due to read error"
            file_entry['metadata']['last_reviewed'] = datetime.datetime.now().isoformat()
            self.stats["errors"] += 1
            return file_entry
        
        try:
            # Get description
            description = self.description_chain.invoke({
                "file_name": file_name,
                "file_type": file_type,
                "file_path": file_path,
                "file_size": file_size,
                "file_contents": file_contents
            }).strip()
            
            # Get security observations
            security_obs = self.security_chain.invoke({
                "file_name": file_name,
                "file_type": file_type,
                "file_path": file_path,
                "file_size": file_size,
                "file_contents": file_contents
            }).strip()
            
            # Update file entry
            file_entry['description'] = description
            file_entry['security_observations'] = security_obs
            file_entry['metadata']['last_reviewed'] = datetime.datetime.now().isoformat()
            
            self.stats["analyzed_files"] += 1
            
        except Exception as e:
            print(f"Error analyzing {file_path}: {e}")
            file_entry['description'] = file_entry.get('description', '') or "Error during analysis"
            file_entry['security_observations'] = file_entry.get('security_observations', '') or "Error during security analysis"
            self.stats["errors"] += 1
            
        return file_entry
    
    def _save_yaml(self):
        """Save updated YAML data back to file"""
        try:
            with open(self.yaml_file, 'w') as f:
                yaml.dump(self.yaml_data, f, default_flow_style=False, sort_keys=False)
        except Exception as e:
            print(f"Error saving YAML file: {e}")
    
    def analyze_files(self):
        """
        Main method to analyze all files in the YAML data
        """
        start_time = time.time()
        print(f"Starting security analysis using model: {self.model_name}")
        
        # Add scan info if not present
        if 'analysis_info' not in self.yaml_data:
            self.yaml_data['analysis_info'] = {}
        
        total_files = 0
        analyzed_count = 0
        
        for folder_entry in self.yaml_data.get('folders', []):
            for i, file_entry in enumerate(folder_entry.get('files', [])):
                total_files += 1
                self.stats["total_files"] += 1
                
                # Check if file should be analyzed
                if self._should_analyze_file(file_entry):
                    # Update stats for progress tracking
                    analyzed_count += 1
                    
                    # Show progress
                    if analyzed_count % 5 == 0 or self.verbose:
                        elapsed = time.time() - start_time
                        print(f"Analyzed {analyzed_count} files so far (elapsed: {elapsed:.2f}s)")
                    
                    # Analyze file
                    folder_entry['files'][i] = self._analyze_file(file_entry)
                    
                    # Save periodically to avoid losing progress
                    if analyzed_count % 20 == 0:
                        self._save_yaml()
                        print(f"Progress saved. {analyzed_count} files analyzed so far.")
        
        # Update analysis info
        analysis_duration = time.time() - start_time
        self.yaml_data['analysis_info']['last_analysis'] = datetime.datetime.now().isoformat()
        self.yaml_data['analysis_info']['analysis_duration_seconds'] = round(analysis_duration, 2)
        self.yaml_data['analysis_info']['model_used'] = self.model_name
        self.yaml_data['analysis_info']['files_analyzed'] = self.stats["analyzed_files"]
        self.yaml_data['analysis_info']['files_skipped'] = {
            "recently_reviewed": self.stats["skipped_recently_reviewed"],
            "file_size": self.stats["skipped_size"],
            "file_type": self.stats["skipped_file_type"]
        }
        self.yaml_data['analysis_info']['errors'] = self.stats["errors"]
        
        # Save final result
        self._save_yaml()
        
        print(f"\nAnalysis completed in {analysis_duration:.2f} seconds.")
        print(f"Total files: {self.stats['total_files']}")
        print(f"Files analyzed: {self.stats['analyzed_files']}")
        print(f"Files skipped (recently reviewed): {self.stats['skipped_recently_reviewed']}")
        print(f"Files skipped (size): {self.stats['skipped_size']}")
        print(f"Files skipped (file type): {self.stats['skipped_file_type']}")
        print(f"Errors: {self.stats['errors']}")
        print(f"Results saved to {self.yaml_file}")

def get_available_file_types(yaml_file: str) -> Set[str]:
    """
    Get a list of all file types in the YAML file
    
    Args:
        yaml_file (str): Path to the YAML file
        
    Returns:
        set: Set of unique file types
    """
    file_types = set()
    
    try:
        with open(yaml_file, 'r') as f:
            data = yaml.safe_load(f)
            
        for folder_entry in data.get('folders', []):
            for file_entry in folder_entry.get('files', []):
                file_type = file_entry.get('file_type')
                if file_type:
                    file_types.add(file_type)
    
    except Exception as e:
        print(f"Error loading YAML to get file types: {e}")
    
    return file_types

def main():
    parser = argparse.ArgumentParser(
        description='Analyze files in a YAML file for security issues using Ollama'
    )
    parser.add_argument('--yaml-file', '-y', required=True, 
                      help='Path to the YAML file generated by the directory scanner')
    parser.add_argument('--target-dir', '-d', required=True, 
                      help='Target directory containing the files')
    parser.add_argument('--model', '-m', default=DEFAULT_MODEL, help=f'Ollama model to use (default: {DEFAULT_MODEL})')
    parser.add_argument('--recent-days', '-r', type=int, default=DEFAULT_RECENT_DAYS, 
                        help=f'Number of days to consider a file as recently reviewed (default: {DEFAULT_RECENT_DAYS})')
    parser.add_argument('--max-file-size', '-s', type=float, default=DEFAULT_MAX_FILE_SIZE_MB,
                        help=f'Maximum file size in MB to analyze (default: {DEFAULT_MAX_FILE_SIZE_MB}MB)')
    parser.add_argument('--include-all-types', '-a', action='store_true', 
                        help='Analyze all file types, not just code files')
    parser.add_argument('--force-all', '-f', action='store_true',
                        help='Force analysis of all files, even recently reviewed ones')
    parser.add_argument('--list-file-types', '-l', action='store_true',
                        help='List all file types in the YAML file and exit')
    parser.add_argument('--file-types', '-t', nargs='+',
                        help='List of specific file types to analyze (e.g., "text/x-python text/x-sh")')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Print verbose output')
    
    args = parser.parse_args()
    
    # Ensure yaml file exists
    if not os.path.isfile(args.yaml_file):
        print(f"Error: YAML file '{args.yaml_file}' does not exist.")
        print(f"Use --yaml-file (-y) to specify the YAML file path")
        return 1
        
    # Ensure target directory exists
    if not os.path.isdir(args.target_dir):
        print(f"Error: Target directory '{args.target_dir}' does not exist.")
        print(f"Use --target-dir (-d) to specify the directory containing the files")
        return 1
    
    # List file types if requested
    if args.list_file_types:
        file_types = get_available_file_types(args.yaml_file)
        print("Available file types in the YAML file:")
        for file_type in sorted(file_types):
            print(f"  - {file_type}")
        return 0
    
    # Determine file types to analyze
    file_types = None  # None means use defaults
    if args.include_all_types:
        file_types = []  # Empty list means include all
    elif args.file_types:
        file_types = args.file_types
    
    # Create analyzer
    analyzer = SecurityAnalyzer(
        yaml_file=args.yaml_file,
        target_dir=args.target_dir,
        model_name=args.model,
        recent_days=args.recent_days,
        max_file_size_mb=args.max_file_size,
        skip_reviewed=not args.force_all,
        file_types=file_types,
        force_all=args.force_all,
        verbose=args.verbose
    )
    
    # Run analysis
    try:
        analyzer.analyze_files()
    except KeyboardInterrupt:
        print("\nAnalysis interrupted by user.")
        return 1
    except Exception as e:
        print(f"\nError during analysis: {e}")
        return 1
    
    return 0

if __name__ == '__main__':
    # Show usage example if no arguments provided
    import sys
    if len(sys.argv) == 1:
        print("Example usage:")
        print("  python security-step-2-analyzer.py --yaml-file directory_scan.yaml --target-dir /path/to/project")
        print("  python security-step-2-analyzer.py -y directory_scan.yaml -d /path/to/project --verbose")
        print("\nUse -h or --help for more options")
        sys.exit(1)
    
    main()